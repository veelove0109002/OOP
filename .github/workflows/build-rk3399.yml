name: build rk3399 (arm64)
on:
  push:
    branches:
      - dev
      - main
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.2.3)'
        required: true
        type: string
      board:
        description: 'RK3399 板卡型号（自动选择官方镜像地址）'
        required: true
        type: choice
        options:
          - rockpi-4b
          - nanopc-t4
          - nanopi-m4
          - rockpro64
          - firefly-rk3399
        default: rockpi-4b
      distro:
        description: '基础系统发行版'
        required: true
        type: choice
        options:
          - bookworm
          - jammy
        default: bookworm
      base_image_url:
        description: '可选：自定义镜像链接（http/https 的 .img/.img.xz/.zip）。留空则按板卡与发行版自动选择'
        required: false
        type: string

jobs:
  build-arm64:
    runs-on: ubuntu-latest
    name: Build for RK3399 (ARM64)
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up docker image context
        run: ./scripts/ci_helper.sh prepare

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build docker image (arm64)
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.DOCKER_BUILD_CONTEXT_DIR }}
          file: ${{ env.DOCKER_BUILD_CONTEXT_DIR }}/Dockerfile.build
          platforms: linux/arm64
          tags: ${{ env.DOCKER_BUILD_TAG }}
          push: false
          load: true

      - name: Set up Node.js
        uses: actions/setup-node@v5
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: "**/package-lock.json"

      - name: Set up Golang
        uses: actions/setup-go@v6
        with:
          go-version: "^1.25.1"

      - name: Build frontend
        run: make frontend

      - name: Build application for RK3399 (ARM64, pure Go)
        env:
          # 覆盖默认的 armv7，强制生成 arm64 二进制；无 aarch64 工具链时使用 CGO_DISABLED
          GO_ARGS: "GOOS=linux GOARCH=arm64 CGO_ENABLED=0"
        run: ./scripts/ci_helper.sh make build_dev

      - name: Package artifact with version (workflow_dispatch only)
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version != '' }}
        run: |
          VERSION="${{ github.event.inputs.version }}"
          cp bin/jetkvm_app "bin/jetkvm_app_${VERSION}_linux_arm64"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: jetkvm-app-arm64
          path: bin/jetkvm_app

      - name: Build bootable RK3399 SD image (workflow_dispatch only)
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version != '' }}
        run: |
          set -euo pipefail
          VERSION="${{ github.event.inputs.version }}"
          BOARD="${{ github.event.inputs.board }}"
          DISTRO="${{ github.event.inputs.distro }}"
          BASE_URL="${{ github.event.inputs.base_image_url }}"
          # Trim leading/trailing spaces in user-provided URL
          BASE_URL="$(printf '%s' "$BASE_URL" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"

          # If user didn't provide URL, choose based on board
          if [ -z "$BASE_URL" ]; then
            case "$BOARD" in
              rockpi-4b|nanopc-t4|nanopi-m4|rockpro64|firefly-rk3399)
                BASE_URL="https://redirect.armbian.com/${BOARD}/${DISTRO}/current"
                ;;
              *)
                echo "::error::未识别的板卡型号：$BOARD，请提供 base_image_url 为有效的 http/https 链接"
                exit 1
                ;;
            esac
          fi

          # Validate URL
          if ! [[ "$BASE_URL" =~ ^https?:// ]]; then
            echo "::error::base_image_url 必须为有效的 http/https 链接，例如 https://example.com/armbian.img.xz"
            exit 1
          fi

          echo "Install tools"
          sudo apt-get update -y
          sudo apt-get install -y xz-utils gzip unzip rsync parted e2fsprogs dosfstools ca-certificates

          echo "Download base image"
          mkdir -p work
          cd work
          # Robust download to fixed name
          set +e
          curl -fSL --retry 3 --retry-delay 2 "$BASE_URL" -o base.download
          CURL_RC=$?
          if [ $CURL_RC -ne 0 ] && echo "$BASE_URL" | grep -qE '^https?://redirect\.armbian\.com/'; then
            ALT_URL="${BASE_URL/https:/http:}"
            echo "HTTPS 下载失败，尝试使用 HTTP: $ALT_URL"
            curl -fSL --retry 3 --retry-delay 2 "$ALT_URL" -o base.download
            CURL_RC=$?
            # 如果指定了发行版仍失败，尝试不带发行版的 current
            if [ $CURL_RC -ne 0 ]; then
              FALLBACK_URL="http://redirect.armbian.com/${BOARD}/current"
              echo "按 board fallback: $FALLBACK_URL"
              curl -fSL --retry 3 --retry-delay 2 "$FALLBACK_URL" -o base.download
              CURL_RC=$?
            fi
          fi
          set -e
          [ $CURL_RC -eq 0 ] || { echo "::error::下载基础镜像失败：$BASE_URL"; exit 1; }

          echo "Prepare .img from downloaded file"
          # Prepare base.img from base.download using stream to avoid filename dependencies
          if file base.download | grep -qi 'XZ'; then
            xz -dc base.download > base.img
          elif file base.download | grep -qi 'gzip'; then
            gzip -dc base.download > base.img || gunzip -c base.download > base.img
          elif file base.download | grep -qi 'Zip'; then
            unzip -o base.download
            IMG_CANDIDATE=$(ls -1 *.img 2>/dev/null | head -n1 || true)
            test -n "$IMG_CANDIDATE" || { echo "::error::zip 文件中未找到 .img"; exit 1; }
            mv "$IMG_CANDIDATE" base.img
          else
            # Assume it's raw .img
            mv base.download base.img
          fi

          test -f base.img || { echo "::error::未能准备出 base.img"; exit 1; }

          echo "Attach loop device and detect partitions"
          sudo losetup -Pf base.img
          LOOP=$(sudo losetup -j base.img | awk -F: '{print $1}')
          echo "Loop device: $LOOP"

          BOOT_DEV=""
          ROOT_DEV=""
          for P in $(lsblk -ln -o NAME,TYPE -p "$LOOP" | awk '$2=="part"{print $1}'); do
            FSTYPE=$(sudo blkid -o value -s TYPE "$P" || true)
            if [ "$FSTYPE" = "vfat" ] || [ "$FSTYPE" = "fat32" ]; then BOOT_DEV="$P"; fi
            if [ "$FSTYPE" = "ext4" ] || [ "$FSTYPE" = "ext3" ]; then ROOT_DEV="$P"; fi
          done
          echo "BOOT_DEV=$BOOT_DEV ROOT_DEV=$ROOT_DEV"
          [ -n "$ROOT_DEV" ] || { echo "::error::未检测到 rootfs(ext4) 分区"; exit 1; }

          echo "Mount partitions"
          sudo mkdir -p /mnt/rk/root /mnt/rk/boot
          sudo mount "$ROOT_DEV" /mnt/rk/root
          if [ -n "$BOOT_DEV" ]; then sudo mount "$BOOT_DEV" /mnt/rk/boot || true; fi

          echo "Install JetKVM binary"
          # ensure target dirs exist
          sudo mkdir -p /mnt/rk/root/usr/local/bin
          sudo mkdir -p /mnt/rk/root/var/run
          sudo mkdir -p /mnt/rk/root/var/log
          sudo install -m 0755 ../bin/jetkvm_app /mnt/rk/root/usr/local/bin/jetkvm_app

          echo "Install UI assets (if present)"
          if [ -d "../ui/dist" ]; then
            sudo mkdir -p /mnt/rk/root/opt/jetkvm/ui
            sudo rsync -a ../ui/dist/ /mnt/rk/root/opt/jetkvm/ui/
          elif [ -d "../ui/build" ]; then
            sudo mkdir -p /mnt/rk/root/opt/jetkvm/ui
            sudo rsync -a ../ui/build/ /mnt/rk/root/opt/jetkvm/ui/
          fi

          echo "Create service (systemd or Buildroot init.d)"

          # Try systemd unit (if systemd exists)
          sudo mkdir -p /mnt/rk/root/etc/systemd/system
          printf '%s\n' \
            '[Unit]' \
            'Description=JetKVM Service' \
            'After=network.target' \
            '' \
            '[Service]' \
            'Type=simple' \
            'ExecStart=/usr/local/bin/jetkvm_app' \
            'Restart=always' \
            'RestartSec=3' \
            '' \
            '[Install]' \
            'WantedBy=multi-user.target' \
          | sudo tee /mnt/rk/root/etc/systemd/system/jetkvm.service >/dev/null

          # Enable via systemd if present; otherwise create Buildroot init.d script
          if sudo chroot /mnt/rk/root /bin/bash -c 'command -v systemctl >/dev/null 2>&1'; then
            sudo chroot /mnt/rk/root /bin/bash -c "systemctl enable jetkvm.service || true"
          else
            echo "Systemd not found, installing Buildroot init.d script S99jetkvm"
            sudo mkdir -p /mnt/rk/root/etc/init.d
            printf '%s\n' \
              '#!/bin/sh' \
              '### BEGIN INIT INFO' \
              '# Provides:          jetkvm' \
              '# Required-Start:' \
              '# Required-Stop:' \
              '# Default-Start:     S' \
              '# Default-Stop:' \
              '# Short-Description: JetKVM Service' \
              '### END INIT INFO' \
              '' \
              'APP="/usr/local/bin/jetkvm_app"' \
              'PIDFILE="/var/run/jetkvm.pid"' \
              '' \
              'have_ssd() {' \
              '  command -v start-stop-daemon >/dev/null 2>&1 || command -v /sbin/start-stop-daemon >/dev/null 2>&1' \
              '}' \
              '' \
              'do_start() {' \
              '  if have_ssd; then' \
              '    SSD=$(command -v start-stop-daemon || command -v /sbin/start-stop-daemon)' \
              '    "$SSD" -S -b -m -p "$PIDFILE" -x "$APP"' \
              '  else' \
              '    nohup "$APP" >/var/log/jetkvm.log 2>&1 &' \
              '    echo $! > "$PIDFILE"' \
              '  fi' \
              '}' \
              '' \
              'do_stop() {' \
              '  if have_ssd; then' \
              '    SSD=$(command -v start-stop-daemon || command -v /sbin/start-stop-daemon)' \
              '    "$SSD" -K -p "$PIDFILE" -x "$APP"' \
              '  else' \
              '    [ -f "$PIDFILE" ] && kill "$(cat "$PIDFILE")" 2>/dev/null || true' \
              '    rm -f "$PIDFILE"' \
              '  fi' \
              '}' \
              '' \
              'case "$1" in' \
              '  start|"")' \
              '    do_start' \
              '    ;;' \
              '  stop)' \
              '    do_stop' \
              '    ;;' \
              '  restart)' \
              '    do_stop; sleep 1; do_start' \
              '    ;;' \
              '  *)' \
              '    echo "Usage: $0 {start|stop|restart}" >&2' \
              '    exit 1' \
              '    ;;' \
              'esac' \
              'exit 0' \
            | sudo tee /mnt/rk/root/etc/init.d/S99jetkvm >/dev/null
            sudo chmod +x /mnt/rk/root/etc/init.d/S99jetkvm
          fi

          echo "Sync and cleanup"
          sync
          sudo umount /mnt/rk/boot || true
          sudo umount /mnt/rk/root || true
          sudo losetup -d "$LOOP" || true

          echo "Output final image (compress to stay under GitHub 2GiB limit)"
          cd ..
          xz -T0 -9 -c work/base.img > "jetkvm-rk3399-${VERSION}.img.xz"
          sha256sum "jetkvm-rk3399-${VERSION}.img.xz" > "jetkvm-rk3399-${VERSION}.img.xz.sha256"

      - name: Upload bootable image to Release
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version != '' }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ github.event.inputs.version }}
          name: jetkvm v${{ github.event.inputs.version }}
          generate_release_notes: true
          files: |
            jetkvm-rk3399-${{ github.event.inputs.version }}.img.xz
            jetkvm-rk3399-${{ github.event.inputs.version }}.img.xz.sha256

      - name: Create GitHub Release and upload asset
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version != '' }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ github.event.inputs.version }}
          name: jetkvm v${{ github.event.inputs.version }}
          generate_release_notes: true
          files: |
            bin/jetkvm_app_${{ github.event.inputs.version }}_linux_arm64